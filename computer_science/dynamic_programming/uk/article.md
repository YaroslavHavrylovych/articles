Найважливіша частина частина задач (від пер. описаних нижче) може бути вирішена
із допомогою 
[Динамічного Програмування](https://uk.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D1%96%D1%87%D0%BD%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) (надалі ДП). 
Можливість долати проблеми такого типу значно
покращить вашу майстерність. Я спробую допомогти вам зрозуміти підхід до
вирішення проблем з допомогою ДП. Стаття побудована на прикладах,
оскільки дуже важко зрозуміти тему базуючись винятково на теорії.

Примітка: якщо вам стало нудно під час прочитання будь-якої секції - 
пропускайте її і йдіть до наступної.

## 1. Замість вступу (для початківців)

Що таке динамічне програмування і як його можна описати?
ДП - це алгоритмічна техніка яка, за звичай, базується на рекурентній формулі
і на якомусь (навіть декількох) початковому стані. Частковий розв'язок задачі
базується на часткових розв'язках підзадач знайдених раніше. ДП задачі мають
[поліноміальний час розв'язку](https://uk.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81_%D1%81%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%96_P),
що забезпечує набагато швидший розв'язок, аніж альтернативні техніки:
[пошук з поверненням](https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D1%88%D1%83%D0%BA_%D0%B7_%D0%B2%D0%B5%D1%80%D1%82%D0%B0%D0%BD%D0%BD%D1%8F%D0%BC),
[повний перебір](https://uk.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%C2%AB%D0%B3%D1%80%D1%83%D0%B1%D0%BE%D1%97_%D1%81%D0%B8%D0%BB%D0%B8%C2%BB) та інші.


*Зараз давайте зрозуміємо основну ідею ДП на прикладі:*

Дано N монет і їх значення (V1, V2, ..., VN), і число S. Знайти мінімальну
кількість монет, сума значень яких рівна S (кількість монет кожного типу необмежена).
Повідомити, якщо S не може бути зібрана із наявних монет.

Підхід до рішення:

Спочатку необхідно знайти *стан*, для якого оптимальний розв'язок вже знайдений
і за допомогою якого ми можемо знайти оптимальний розв'язок для наступного стану.

Але що таке *стан*?

Під станом мається на увазі опис розв'язку певної підзадачі.
Для прикладу станом може бути підзадача пошуку суми *i*, де i <= S 
(від пер. перед тим як знайти монети які складаються до S=10, ми знайдемо
монети як складаються до 1,2,3...9). Для знаходження стану *i* ми мусимо спочатку
знайти усі стани j, де j < i. Маючи мінімальну кількість монет які дають суму
*i*, ми можемо легко знайти наступний стан *i+1*.

Як ми можемо знайти наступний стан?

Ми шукаємо стан *i*. Для кожної монети j, де V(j) <= i, потрібно взяти мінімальну кількість
монет (вже знайдену, бо ми знайшли всі попередні стани до *i*) для суми *i-Vj*. 
Нехай це число буде *m*. Якщо *m+1* (*+1* бо ми додамо монету V(j) до розв'язку) менше ніж
знайдена мінімальна кількість монет для стану *i*, тоді ми запам'ятовуємо новий результат
для стану *i*.

Для усвідомлення підходу розглянемо приклад із значеннями:

Дано монети номіналами 1, 3 і 5. Сума *S* яку потрібно знайти рівна 11.

1. Для початку ми занотуємо, що для стану *0* (Сума 0) ми маємо рішення, яке потребує 0 монет.
2. Переходимо до наступного стану 1. Для цього стану, по-перше, ми ще не маємо жодного
розв'язку (нескінченна кількість монет буде достатньою для позначення неіснуючого розв'язку). 
Далі ми бачимо, що лиш одна монета менша, або рівна 1 (V1 із значенням 1).
Аналізуючи це ми бачимо, що для стану *1-V1* ми маємо рішення - 0 монет (значення *m*).
Оскільки ми додаємо одну монету до даного рішення (*m+1*) - ми маємо рішення 1 для стану/суми 1.
Це єдине наявне рішення для цієї суми і ми його зберігаємо. 
3. Далі ми переходимо до стану 2. Знову лиш одна монета менша, або рівна 2 - монета V1. 
Оптимальне рішення для суми (2-1) це монет 1. Отже монета 1 плюс рішення 
для попереднього стану (1) мають суму 2. Таким чином ми можемо утворити суму 2
за допомогою двох монет. Це єдине і найкраще рішення для стану 2.
4. Переходимо до стану 3. Тепер ми вже маємо дві монети на аналіз: 1 і 3. Перевіримо першу монету.
(3-1)=2, а для стану 2 ми маємо рішення рівне двом. Отже нове рішення для стану 3 включає три монети.
Тепер розглянемо монету із значенням 3. Стан (його значення) яке мусить бути
доданим до монети 3, щоб отримати суму 3 це 0. Ми знаємо, що для стану 0 нам необхідно 0 монет.
Таким чином ми можемо отримати суму 3 за допомогою єдиної монети номіналом 3.
Очевидно, що це рішення краще за попереднє для стану 3, що потребувало 3 монети.
Ми оновлюємо найкраще значення для стану 3 до 1-єї монети.
5. Те саме ми продовжуємо для станів 4, 5 і т.д.

**Псевдокод**

```
Set Min[i] equal to Infinity for all of i
Min[0]=0For i = 1 to S
For j = 0 to N - 1If (Vj<=i AND Min[i-Vj]+1 < Min[i])
Then Min[i]=Min[i-Vj]+1
Output Min[S]
```

Ось таблиця рішень для всіх станів:

 S  | Стан | Нова монета (попередній стан)
--- | ---- | -----------------------------
0   |  0   |  -
1   |  1   |  1 (0)
2   |  2   |  1 (1)
3   |  1   |  3 (0)
4   |  2   |  1 (3)
5   |  1   |  5 (0)
6   |  2   |  3 (3)
7   |  3   |  1 (6)
8   |  2   |  3 (5)
9   |  3   |  1 (8)
10  |  2   |  5 (5)
11  |  3   |  1 (10)

В результаті ми знайшли рішення із трьох монет, які складаються до 11.

Додатково, якби ми запам'ятовували як ми потрапили до конкретного стану,
ми могли б знайти монети які складають наше рішення. Для прикладу: до суми 11 ми дістались
додавши монету 1 до стану 10. До стану 10 ми дістались із стану 5. До 5 із 0. Так ми
бачимо, що монети які складаються до 11 це 1, 5 і 5.

Зрозумівши базовий приклад де використовується ДП, ми можемо побачити інший підхід до нього.
Він включає зміну (оновлення) найкращого знайденого раніше рішення для стану/суми *i*,
як тільки краще рішення було знайдене. В такому випадку стани не рахуються послідовно.
Розглянемо наведений вище приклад ще один раз. Ми почали із рішення 0 для стану 0. Спробуйте тепер
додати першу монету (номіналом 1) до всіх сум, які було знайдено. Якщо результат *t* буде отримано
з використанням меншої кількості монет - ми оновимо рішення для нього. Далі ми зробимо те саме для
другої монети, третьої і т.д. для решти. В деталях: ми додамо монету 1 до стану 0 і отримаємо 1.
Оскільки це перше рішення - воно буде найкращим на даний момент і ми позначимо S[1] = 1.
Додавши монету 1 до S[1] ми матимемо S[2]=2, далі S[3]=3 і т.д. Коли ми отримаємо всі S для монети V1,
ми перейдемо до монети V2 (номіналом 3). Додавши V3 до S[0] ми матимемо рішення
для S[3]=1, яке буде краще за попереднє S[3]=3, тому ми збережемо його. Далі ми отримаємо
S[4]=2, що теж оновить попереднє рішення S[4]=4. Продовжуючи таким чином для усіх наявних
монет ми теж можемо знайти найкраще рішення для S[11].

## 2. Елементарно

Лише найпростіші проблеми ми обговорювали до цього. Тепер давайте глянемо як знайти шлях переходу від
одного стану до іншого для більш складної задачі. Для цього ми введемо 
новий термін *рекурентне відношення*, який являє собою зв'язок між нижчим і вищим станами.

Давайте глянемо на прикладі:

Дана послідовність N чисел - A[1], A[2], ..., A[N].
Знайти довжину найдовшу не спадаючу послідовність.

Як було наголошено вище, спочатку ми повинні визначити що таке "стан" який являє підпроблему
а далі знайти рішення. Слід виокремити, що у більшості випадків стан покладається лиш
на стани які розташовані нижче і незалежні від вищих станів.

Визначимо стан *i* як найдовшу не зростаючу послідовність, крайнє число якої A[i].
Цей стан містить лиш дані про довжину послідовності. Занотуйте, що для *i < j* стан
*i* незалежний від стану j (іншими словами *i* лишається незмінним під час обрахунку j).
Тепер окреслимо яким чином ці стани пов'язані. Маючи рішення для усіх станів менших *i*,
ми можемо перейти до обрахунку стану *j*. Спочатку ми ініціалізуємо стан з рішенням 1,
яке містить лиш *і*-те число. Тепер для кожного i < j глянемо чи є можливим перехід
від стану *i* до стану *j*. Це можливо лиш за умови, що A[i] >= A[j], оскільки
нам потрібна не спадаюча послідовність. Тому якщо *S[i]* (рішення для стану i) + 1
(число A[j], що додається до послідовності) краще ніж рішення знайдене для i (S[i] + 1 > S[j]),
ми записуємо S[j]=S[i]+1. Таким чином ми послідовно знаходимо найкращі рішення для кожного
*i*, аж поки не досягнемо стану N.

Дослідимо це на послідовності випадкових чисел: 5, 3, 4, 8, 6, 7:
i  | Довжина найдовшої не спадаючої послідовності (стан) i | Стан з якого ми перейшли в поточний
-- | ----------------------------------------------------- | -----------------------------------
1  |                            1                          |      1 (перше число)
2  |                            1                          |      2 (друге число)
3  |                            2                          |      2
4  |                            3                          |      3
5  |                            3                          |      3
6  |                            4                          |      5

*Задачі для практики:*

Дано неорієнтований граф G, який має N (1 < N <= 1000) вершин і позитивні ваги ребер.
Знайти найкоротший шлях з вершини 1 до вершини N, або показати, що шляху не існує.

Підказка: На кожному кроці серед вершини які ще не було пройдено і серед тих, до яких
шлях від вершини 1 вже існує, обрати той, який має найкоротший на даний момент шлях від вершини 1 до поточної. 

*Для самостійної практики спробуйте розв'язати наступні задачі:*

[ЗігЗаг](https://community.topcoder.com/stat?c=problem_statement&pm=1259&rd=4493)

[Погані сусіди](https://community.topcoder.com/stat?c=problem_statement&pm=2402&rd=5009)

[Квітковий сад](https://community.topcoder.com/stat?c=problem_statement&pm=1918&rd=5006)

## 3. Середнячок 

А тепер давайте глянемо як управлятись із двовимірними проблемами ДП.

Задача:

Дано таблицю N x M, де кожна клітинка містить число, що відповідає кількості яблук.
Починаючи з лівого-верхнього кутку ви можеш здійснити рух праворуч або донизу.
Проходячи комірку ви збираєш яблука. Яку максимальну кількість яблук ви можеш зібрати?

Дана проблема вирішується таким самим чином як і інші проблеми ДП.

По-перше, як і завжди, нам потрібно визначити стан. Важливо звернути увагу на те,
що до кожної клітинки ми можемо попасти на більш ніж двома методами: 
згори (якщо це не клітинки верхнього ряду) і зліва (якщо це не клітинки крайнього лівого ряду).
Таким чином щоб знайти розв'язок для будь-якої клітинки [i,j], нам потрібно знайти
найкращі розв'язки потрапляння до клітинки ліворуч і клітинки згори (клітинки
які є вхідними точками, до даної клітинки).

Із наведеного вище ми можемо легко утворити рекурентне відношення:

S\[i][j]=A\[i][j] + max(S\[i-1][j], if i>0 ; S\[i][j-1], if j>0),

де *i* являє собою рядок і *j*, відповідно, стовпчик таблиці; 

Лівий-верхній кут має координати [0,0];

A\[i][j] містить кількість яблук які знаходяться в клітинці (i,j)

S\[i][j] рахуємо рухаючись зліва на право в кожному рядку і обчислюючи рядки з верху до низу,
або рухаючись спочатку згори до низу в кожному стовпчику обчислюючи рядки з ліва на право.

**Псевдокод:**

```
For i = 0 to N - 1
	For j = 0 to M - 1
	S[i][j] = A[i][j] +
        max(S[i][j-1], if j>0 ; S[i-1][j], if i>0 ; 0)

Output S[n-1][m-1]
```

*Ось декілька проблем з Topcoder для практики:*

[Оминаючи дороги](https://community.topcoder.com/stat?c=problem_statement&pm=1889&rd=4709)

[Шахові метрики](https://community.topcoder.com/stat?c=problem_statement&pm=1592&rd=4482)

## 4. Вище-середнього

У даній секції розглядаються проблеми, які мають додаткові умови в додачу до значень,
які мусять бути обрахованими.

Гарним прикладом буде наступна задача:

Дано неорієнтований граф G, що має позитивну вагу ребер і N вершин.

На початку ви маєте певну суму грошей M. Для проходження вершини i, ви мусите заплатити S[i] грошей.
Якщо грошей недостатньо - ви не можете пройти вершину. Знайти найкоротший шлях
із вершини 1 до вершини N, задовільнивши усі умови, або довести, що такого шляху не існує.
Якщо існує більше одного шляху однакової довжини, тоді вивести дешевший.

Обмеження: 1 < N <= 100; 0 <= M <= 100; для кожної *i*, 0 <= S[i] <= 100.

Як ми можемо бачити, це майже класична задача алгоритму 
[Дейкстра](https://uk.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D0%B8)
(знаходження найкоротшого шляху між двома вершинами), але з одним обмеженням.
У класичному алгоритмі ми б використовували одновимірний масив Min[i], який
містить найкоротший шлях до вершини *i*. Але в даній задачі ми повинні також зберігати
інформацію про наявні гроші. Тому логічним виглядає розширення масиву до чогось схожого
на Min\[i][j]. Значення в Min\[i][j] - це довжина найкоротшого шляху до вершини *i*,
а індекс *j* - кількість наявних грошей. 
В такому випадку задача спрощується до оригінальної задачі пошуку шляху.
На кожному кроці ми знаходимо *непройдени* стан *(i,j)*, для якого найкоротший шлях було знайдено.
Ми позначає стан як *пройдений* (щоб не використовувати його пізніше), і для кожної сусідньої
вершини ми перевіряємо, чи можна оновити/покращити найкоротший шлях.
Якщо так - оновлюємо його. Повторюємо даний крок доки існують *непройдені* стани, для яких
шлях було знайдено. Рішення буде знаходитись у Min\[N-1][j] де буде найменше значення,
оскільки значення Min\[N-1][j] - це довжина маршруту. Якщо мінімальних значень
декілька обираємо значення із найбільшим *j* 
(j - кількість грошей, які лишились після маршруту).

**Псевдокод**

```
Set states(i,j) as unvisited for all (i,j)
Set Min[i][j] to Infinity for all (i,j)

Min[0][M]=0

While(TRUE)

Серед усіх unvisited states(i,j) знайти той, де Min[i][j] найменше
(першим буде Min[0][M] - пропустимо його, там просто).
Припустимо, що цей стан (k,l).

Якщо не знайдено жодного стану (k,l) 
для якого Min[k][l] менше ніж Infinity - вийти з While loop.

Позначити state(k,l) як visited

Для усіх сусдів (p) вершини k.
	Якщо (l-S[p]>=0 i Min[p][l-S[p]]>Min[k][l]+Dist[k][p])
		Тоді Min[p][l-S[p]]=Min[k][l]+Dist[k][p]

іншими словами
Якщо для стану (i,j) достатньо грошей для переходу до вершини
p (l-S[p] = кількісті грошей які лишаться після проходження вершини p),
і найкоротший шляха який знайдено для стану (p, l-S[p]) більший 
ніж [найкоротший шлях знайдений для state(k,l)] + [відстань з вершини k до вершини p],
то оновити найкоротший шлях до state(i,j) значенням цієї суми.

End For

End While

Знайти найменше число Min[N-1][j] (для всіх j, 0 <= j <= M);
якщо наявний більше ніж один стан із таким значенням, то обрати
той, де більший j. Якщо не існує state(N-1,j) із значенням 
меншим за нескінченність - то шлях не існує.
```

*Декілька проблем з Topcoder для практики:*

[Коштовності](https://community.topcoder.com/stat?c=problem_statement&pm=1166&rd=4705)

[Художник смуг](https://community.topcoder.com/stat?c=problem_statement&pm=1215&rd=4555)

[Швидкі суми](https://community.topcoder.com/stat?c=problem_statement&pm=2829&rd=5072)

[Короткі паліндроми](https://community.topcoder.com/stat?c=problem_statement&pm=1861&rd=4630)

## 5. Архімайстер ДП

Подальші проблеми вимагатимуть детальних досліджень для того, щоб спростити їх до проблем ДП.

Проблема [Зіркова пригода](https://community.topcoder.com/stat?c=problem_statement&pm=2940&rd=5854) - SRM 208 Div 1:

Дано матрицю в M рядків і N стовпчиків (N x M). У кожній клітинці знаходиться кількість яблук.
Ви починаєте свій рух із лівого-верхнього кутка матриці і за один крок ви можете зробити
рух праворуч, або вниз. Ваша ціль - правий-нижній кут. Після цього потрібно повернутись
назад до лівого-верхньго кутка, а потім знову до правого нижнього.

Під час проходу клітинки ви забираєте із неї усі яблука.

Яку максимальну кількість яблук ви можете зібрати пройшовши увесь цей шлях?

Обмеження: 1 < N, M <= 50; 0 <= M\[i][j] <= 1000

Можна побачити, що ця проблема може бути перетворена у класичну (описана в секції 3),
де ви мусите пройти лише один прохід і лівого-верхнього до правого-нижнього кута і
зібрати максимальну кількість яблук. Це буде краще, якщо ми змінимо подію до класичної.
Уважно гляньте на умову задачі - що потрібно змінити і яким чином, щоб задача була вирішена з допомогою ДП?
Перше, що можна помітити, так це те, що другий прохід (з правого нижнього до лівого перхнього кута)
можна змінити на прохід з лівого-верхнього до правого нижнього. Якщо ви пройдете одним
маршрутом знизу до гори і згори до низу, ви зберете однакову кількість яблук.
Це певним чином полегшує задачу. Тепер ми можемо розглянути 3 проходи як
лівий, середній і правий. Зверніть увагу на перетин двох проходів (рис. 1):

![рис. 1 Перетин маршрутів](https://www.topcoder.com/i/education/dynProg_1.gif "рис. 1 Перетин маршрутів")

Ми можемо замінити ці маршрути наступними без впливу на результат (рис. 2):

![рис. 2 Маршрути, що не перетинаються](https://www.topcoder.com/i/education/dynProg_2.gif "рис. 2 Маршрути, що не перетинаються")

Таким чином ми матимемо 3 шляхи, які ми можемо розглядати як лівий, середній і правий.
Навіть більше, ми можемо побачити, що для отримання найкращого результату маршрути
не мусять перетинатись (винятками є лівий-верхній і правий-нижній кути). Отже для
кожного рядку *y* (виключаючи перший і останній)
координата *x* ліній (x1[y], x2[y] і x3[y] відповідно) матиме залежність x1[y] < x2[y] < x3[y].
Зробивши так ми бачимо, що підхід ДП трохи роз'язнився. 

Розглянемо рядок *y*. Припустимо, що для кожної конфігурації x1[y-1],
x2[y-1] і x3[y-1] ми вже маємо шлях який зібрав найбільшу кількість яблук. Базуючись
на такому припущені, ми можемо сконструювати рішення для рядку *y*. Нам потрібно лиш
докумекати до того, як перейти від одного рядку до іншого. Припустимо, що
Max\[i]\[j][k] містить найбільшу кількість яблук зібрану проходом до рядку *y-1* включно,
трьома шляхами, що завершуються в точках i, j та k відповідно. Для наступного
рядку *y*, до кожного Max\[i]\[j]\[k] (отриманого раніше) додайте кількість яблук
розташованих в клітинках (y,i), (y,j) та (y,k). Таким чином ми рухаємось униз із кожним кроком.
Після того, як ми зробили крок, ми мусимо прийняти до уваги те, що шляхи можуть рухатись
у праву сторону. Для утримання шляхів від перетину ми, у першу чергу, розглядаємо рух праворуч
із лівого шляху, потім середнього і правого в останню чергу. Для кращого розуміння
подумайте над кроком праворуч із лівого шляху - візьміть кожну можливу пару *k* (де j < k),
і для кожного *i* (де i < j) врахуйте перехід із позиції (i-1, j, k) на позицію (i,j,k).
Маючи рішення для крайнього лівого шляху, почніть обраховувати середній шлях у такий
самий спосіб; потім правий.

*Задачі для практики:*

[Маленький малюнок](https://community.topcoder.com/tc?module=ProblemDetail&rd=4710&pm=1996)

## 6. Маленька допомога

Коли ви читаєте умову задачі і починаєте її вирішувати, гляньте спочатку на обмеження.
Якщо потрібно знайти алгоритм із
[поліноміальним часом розв'язку](https://uk.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81_%D1%81%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%96_P),
тоді є ймовірність, що від вас очікують підхід із використанням ДП. В такому
випадку уважно проаналізуйте, чи існують такі стани (підрозв'язки), із допомогою яких
ви можете отримати наступні підрозв'язки. Маючи це подумайте, як можна перейти із одного стану до іншого.
Якщо це є проблемою ДП, але ви не можете знайти такі стани - спробуйте перетворити проблему
в іншу (приклад у секції 5).
