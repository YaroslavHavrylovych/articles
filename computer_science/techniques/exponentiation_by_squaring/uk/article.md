# Швидке піднесення до степеня

Розв'язуючи одну із задач на [InterviewBit](https://www.interviewbit.com) (як тільки я її згадаю - додам посиланням),
я побачив магічний (і мені невідомий) метод піднесення до степеня, який працював
за логарифмічний час. Якщо відкинути магічну частину, то метод є дуже елегантним і зрозумілим.

Одразу [код](https://github.com/YaroslavHavrylovych/dsa/blob/development/algorithms/math/exponentiation_by_squaring/java/Exponentiation.java). Якщо все зрозуміло, то далі можна і не читати:

```java
long pow(long val, long exp) {
    long res = 1;
    while(exp != 0) {
        if((exp & 1) == 1) res *= val;
        val *= val;
        exp >>= 1;
    }
    return res;
}
```

**Конкретизуємо задачу**: піднести x до степеня n, де x=[1,2,3,...], n = [0,1,2,3,....]

Трохи розігріємо пам'ять і почнемо з того, що процедура піднесення до степеня (звичайним алгоритмом, 
який випливає із 
[визначення](https://uk.wikipedia.org/wiki/%D0%9F%D1%96%D0%B4%D0%BD%D0%B5%D1%81%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B4%D0%BE_%D1%81%D1%82%D0%B5%D0%BF%D0%B5%D0%BD%D1%8F))
виконується за [лінійний час](https://uk.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D0%BE%D0%B2%D0%B0_%D1%81%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D1%96%D1%81%D1%82%D1%8C_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%83#%D0%9B%D1%96%D0%BD%D1%96%D0%B9%D0%BD%D0%B8%D0%B9_%D1%87%D0%B0%D1%81).
Тобто:

```
x^n=x*x*x*....*x (n разів)
```

Кількість цих множень x\*x ми хочемо зменшити, оскільки це операція яка постійно повторюється.
Для цього використаємо важливу властивість степеня:

```mathematica
x^(a+b)=(x^a)*(x^b).
```

Нам потрібно подати n як суму чисел, які будуть між собою пов'язаними (множенням),
тоді x^a та x^b будуть мати спільну частину.

Використаємо те, що будь-яке число можна записати як суму степенів двійки, оскільки це фактично є записом числа у 
[двійковій системі числення](https://uk.wikipedia.org/wiki/%D0%94%D0%B2%D1%96%D0%B9%D0%BA%D0%BE%D0%B2%D0%B0_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F). Візьмо число `177` за приклад:

```mathematica
117=64+32+16+4+1=2^6+2^5+2^4+2^2+2^0. 
```

Позначимо множником нуль степені, яких не вистачає, а ті які є - множником 1: `1*2^6+1*2^5+1*2^4+0*2^3+1*2^2+0*2^1+1*2^0`.

```mathematica
117=1*2^6+1*2^5+1*2^4+0*2^3+1*2^2+0*2^1+1*2^0=1*n6+1*n5+1*n4+0*n3+1*n2+0*n1+1*n0,
n0=1 (res+=n0)
n1=n0+n0
n2=n1+n1 (res+=n2)
n3=n2+n2
...
```

Сума змінюється на множення при зменшення степеня `x^32=x^16*x^16`,
а  `x^64=x^(32+32)=x^32*x^32` і т.д. Кожне наступне число завжди
вдвічі більше за попереднє і, відповідно, включає його у добуток.  Можнонки при `n[i]` завжди 0 або 1 із двійогового запису числа (117` у двійковій формі - це `1110101`).

Тепер мусить бути очевидним, що якщо ми будемо перемножувати
x сам на себе, а результат множити на ті значення x, які мають 1 у двійковому
записі степеня, то ми отримаємо x^117 ціною десяти операцій множення, а не
117 очікуваних.

І ще раз глянемо на [код](https://github.com/YaroslavHavrylovych/dsa/blob/development/algorithms/math/exponentiation_by_squaring/java/Exponentiation.java):

```java
long pow(long x, long n) {
    long res = 1; //результат множення
    while(n != 0) {
        if((n & 1) == 1) res *= val; //x йде в результат
        x *= x; //x = x*x - для наступного розряду
        n >>= 1; //ділення на 2 методом побітового зсуву
    }
    return res;
}
```

Звичайно, ми могли б використати будь-який інший формат запису замість двійкового,
але зручність двійкового в тому, що числа, у більшості мов програмування, 
або зберігаються у двійковій формі запису, або мають зручний метод швидкої конвертації.